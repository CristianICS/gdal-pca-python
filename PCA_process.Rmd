# Intro
La tecnica *Principal Components Analysis* (PCA, en ingles) permite sintetizar la informacion de un conjunto de datos con un gran numero de variables en nuevos componentes no correlacionados entre sí, i.e., los **componentes principales**.

Se utiliza un recorte de una imagen tomada con UAV para realizar el PCA.

## Ideas clave

- El nº de Componentes Principales es el mismo que la dimensionalidad de los datos (e.g. nº de bandas en una imagen). Para una matriz de *n* observaciones y *p* variables, el nº de CP será `min(n - 1, p)`. 
- Un *score* es la distancia de los datos al nuevo eje rotado.
- Los *Eigenvectors* son linearmente independientes, i.e., no estan correlacionados. Cada uno de los CP representa informacion unica.
- Los *loadings* son los coeficientes con los que se obtiene el CP. Un *loading* representa lo bien que un valor puede ser predicho por el *eigenvector*. 
- Los CPs no tienen un significado fisico debido a la rotacion de los ejes, su interpretacion debe hacerse relacionando los *loadings* con las bandas originales.

## Cargar las bandas de la imagen

Se utiliza el paquete `raster`, que incorpora las funciones de GDAL que permiten
leer archivos raster pero **sin cargarlos en la memoria de R**.

```{r}
library('raster')

input_path = "E:\\arqueologia_2022\\celsa_dron\\Yacimiento_Lepida_Celsa\\Lepida Celsa\\Mapas de reflectancia\\Casa_Hercules\\masked_bands\\"

output_PCA_path = "E:\\arqueologia_2022\\celsa_dron\\Yacimiento_Lepida_Celsa\\Lepida Celsa\\Mapas de reflectancia\\Casa_Hercules\\PCA\\"

mosaic <- brick(paste(input_path,"Lepida_Celsa_Casa_Hercules_mosaic.tif",sep=""))
```

La imagen utilizada es un mosaico que agrupa el conjunto de las bandas originales de UAV recortadas.

## Transformar la imagen en un DF
De cara a realizar un PCA, se transforman las bandas de las imágenes en un nuevo DF, siendo las columnas cada una de sus bandas y las filas cada uno de sus píxeles.

```{r}
mosaic.df <- as.data.frame(mosaic)
names(mosaic.df) <- c("ndvi","green","red","red_edge","nir","thermal")
head(mosaic.df)
```

Los valores 0 se corresponden (en su inmensa mayoría) con el área externa a la zona recortada. No se utiliza el valor `NA` por dar errores en el PCA.

## Crear los componentes principales
El PCA se realiza con una función de RBase, `prcomp`. En este ejemplo se escalan los valores, es decir, se estandarizan para evitar diferencias causadas por el tipo de medida, restando cada valor por la media de la variable y dividido después por la desviación estandar. Después de este proceso todos tendrían la misma escala. No haría falta si no se hubiera añadidio el NDVI, al ser datos medidos siempre en reflectividad. 

> Standardization is done by centering the variable by subtracting mean and then 
> bringing them to a common scale by dividing standard deviation. Since the variables 
> (band images) we are dealing with are similar and have the same range, standardization 
> is not necessary but still, it is a good practice to apply.

```{r}
pca <- prcomp(mosaic.df, scale.=TRUE)
```

Una vez realizado el cálculo se guardan los valores de cada PC por píxel en una nueva variable. Sin embargo, estos nuevos valores no se pueden representar como una imagen porque han perdido su estructura. Para devolversela se integra cada componente en una nueva banda del *raster brick* original. 

```{r}
mosaic.pc <- pca$x
mosaic$pc1 <- mosaic.pc[,1]
mosaic$pc2 <- mosaic.pc[,2]
mosaic$pc3 <- mosaic.pc[,3]
mosaic$pc4 <- mosaic.pc[,4]
mosaic$pc5 <- mosaic.pc[,5]
mosaic$pc6 <- mosaic.pc[,6]

# Plot 1st PC
plot(mosaic$pc1,col = cm.colors(15), axes = FALSE, asp=1)
```

## Analizar los resultados

Los nuevos componentes han perdido el significado de las bandas originales, por lo que para su interpretación necesitan relacionarse con los datos iniciales. Este proceso se realiza inspeccionando
la matriz con los *loadings*, i.e., los coeficientes con los que se obtienen los componentes.

```{r}
loadings <- pca$rotation
loadings
write.csv(loadings, file=paste(output_PCA_path,"loadings_matrix.csv",sep=""))
```

Tomando como ejemplo el primer componente, para su obtención se utilizará la siguiente fórmula:

PC1 = green\*0.50 + red\*0.50 + red_edge\*0.50 + nir\*0.50 - ndvi\*0.06

siendo el valor de cada banda el del píxel correspondiente que se esté calculando.

Al haber mezclado información de reflectividad con el NDVI, el primer componente está compuesto por
una mezcla a partes iguales de las bandas con la reflectividad (valor de 0.5 aprox en los *loadings*), aportando muy poco la banda del NDVI. El segundo componente es todo lo contrario, está compuesto casi en su totalidad por la banda con el NDVI.

Mediante la función `summary(prcomp_matrix)` se puede obtener los datos sobre la varianza explicada por cada PC. A continuación se calculan los mismos datos manualmente:

```{r}
# Obtener los eigenvalues (varianza de cada PC, obtenida elevando al cuadrado su desvest)
eigs <- pca$sdev^2

pca_stats <- rbind(
  # Desviacion estandar / raiz cuadrada de la varianza
  SD = sqrt(eigs),
  # Proportion of variance
  Proportion = eigs/sum(eigs),
  Cumulative = cumsum(eigs)/sum(eigs))
colnames(pca_stats) <- c("PC1","PC2","PC3","PC4","PC5","PC6")
pca_stats

# Exportar
write.csv(pca_stats, file=paste(output_PCA_path,"pca_stats.csv",sep=""))
```

## Exportar la imagen
Se exportan los componentes principales de la imagen (bandas 7 a 12) en bandas separadas.

```{r}
# Output
output <- paste(output_PCA_path, "Lepida_Celsa_Casa_Hercules.tif",sep="")

raster::writeRaster(subset(mosaic,7:12),output, bylayer = T, suffix = c("PC1","PC2","PC3","PC4","PC5","PC6"))
```
    
Una vez exportadas, las imágenes contienen un valor *No data* que se corresponde con el valor
mínimo del nuevo raster. Con la herramienta *gdalwarp* se ha vuelto a recortar por el área
correspondiente, forzando un nuevo valor de *No data* con la opción `-dstnodata -10000`. Es
el mismo valor (-10000) que el puesto por defecto cuando se recortan las bandas del UAV mediante
*gdalwarp* por primera vez.

## Referencias

- [Analisis de Componentes Principales - UOC](https://d1wqtxts1xzle7.cloudfront.net/32412395/Componentes_principales-with-cover-page-v2.pdf?Expires=1648819849&Signature=X99FwY5Ut53fnC9J2uT8sYkai~7FN9i8pDt5U84ANByBSodODEPaNuJVwHmrLqum~cWyBT5hA4oQ37QZqZ9HbYVTl1TMLEA2tKlpsEn1zwC49Rxvj-W2B4b5dQo3Orr7COewg-eCkhdIHipJRvoiy5BBr8SFlb47QHUVcsQXXUQLDXUeZZJdIQtTApcs0api9NqG997LogN7cYlcGl4fK~~yOvPAL2YQltd0eWNdshb5WITbhluvbevxC7h4Spc2WfGhP2MJFl2ODs3~EnmYQ-lG~pgPUUtq~TboCjbFRDASYuOp1MwdMzfsTNnzSK26DtIDGIUAIrqeEl9quGKT0g__&Key-Pair-Id=APKAJLOHF5GGSLRBV4ZA)
- [Turorial de PCA en R](https://afit-r.github.io/pca)
- [Paso a paso explicacion PCA](https://builtin.com/data-science/step-step-explanation-principal-component-analysis)
-[Principios b?sicos del PCA](https://towardsdatascience.com/the-basics-principal-component-analysis-83c270f1a73c?gi=84c269d8c697)
- [PCA with R](https://www.datacamp.com/community/tutorials/pca-analysis-r)
- [Escalar variables](https://sebastianraschka.com/faq/docs/pca-scaling.html)
